19.09.2024

VARIABLES
Décla. de cont. indeter. -> possible mais pas ouf
Si pas init. == undefined. pas zéro. Juste mémoire pur. (on laisse le truc tel quel et tu te démerde avec ce que tu trouves lol. Pas prédictible. Mais pas true rand.)
Décla. de cont. Init. -> good 
Permets un follow-up du contenu (et pour clean le truc une fois qu'on en a plus besoin ?)
--------------
Décla required pour avoir SA place selon SA taille pour booké la bonne place à la bonne taille
-> chacun son adresse, je vis pas chez le voisin quoi et si j'ai 3 gosses, ça fit peut-être pas son endroit…
-------------- 
Mémoire == petit bout de 8 octet (un bit) agloméré
Réf - cours M. Deschamps
_______________________________________
23.09.2024

SUITE VARIABLES
Address format -> 0x0004 (for ex.)
Certains type heavier than some others
-> ex: byte vs. int
Best way is the random way. So we don't choose some that are used.
-------------- 
cin = command in (?) lecture d'info sur la console
literal constant (6 par ex.) truc qui est déjà dans la mémoire, il va juste le lire
-------------- 
3 way to décla var (all the same)
init like C -> int age =6;
init by construct. -> int age (6);
init. uniform -> int age{6}
-> since C++11

Must décla the var, the nearest of where used
-> is alive a short amount of time
-> the nearest declared so it is used only for the time needed.
(very useful for embarqué)
Sometimes she needs to survive so we should declare it elsewhere then above
The longest it is used, the more explicit and complete the var name can be
-------------- 
id name 
-> can't start with a nb
-> need to start with a letter or a _
-> no - (lil shit looking like a _)
-> no shiny carac.
-> no space.
-------------- 
VARIABLES CONSTANTES

init. is mandatory when declared
const int -> constante
Helps to dodge magic nb

-------------- 
TYPES DE BASES

Static and explicit
auto -> the compil will try to guess
Types:
- defined
> how stocked
> op. possible w/

- fundamental
> char (carac. typo) only 8 bits 
-> ascii table associated w/
-> signed -> ful tab
-> not signed -> only + 
-> better unsigned bcs better copy+paste of the tab
> string 
-> is a class 
-> mention honorifique bcs isn't a base type
-> not the case for random shit if we random point by not init. it
-> will stay empty
> int
> byte
> double(more precise than float) - float
> bool
-------------- 
OPÉRATIONS

Litéral constant
- un carac. ''
- chain carac. ""
- int
- double/float
Lives there, is read only

lvalue = localisation value
- left (int age)
- réf to a memory address
- address is accessible by the prog.

rvalue = result value
- right (6)
- not a memory address réf.

Affectations = copie de la valeur de l'exp. à la droite 
(et pas inversément. on met pas la charue avant les boeufs !)
-> int age = 10 
on va attribuer le 10 à age qui en porte sa copie pour l'avoir à cet emplacement de mémoire

Arithmétique doubles
-> + - * double == classical shit behavior
-> + - * int == same as bool
-> / will yeet the fuck it out of the post ,
-> % unlike /, will fucking keep the remaining of the div.
_______________________________________
24.09.2024

SUITE

Modulo use case
-> RSA
-> compteur cyclique
-> 
--------------
OPÉRATEUR D'AFFECTATIONS
+=  -=  *=  %=
Combine opéra. d'arithmétique et d'affectations
--------------
INCRÉMENT-DÉCRÉMENT
++  --

préfixe-suffixe
will incr. before if préfix
will incr. after if suffix
(check p.35 for ex)
--------------
OPÉRATEURS DE COMPARAISONS
<  >  <=  >=  ==  !=
Can compare -> int, double, float, char, string
-> return bool

If string compared -> lexicographique
Classic compa. then when 1st diff. -> compa. their ASCII nb
-> then classic nb compa.
--------------
OPÉRATEURS DE COMPARAISONS TILATÉRALE
Spaceship

A<=>B -> déter. si A<B, A==B ou A>B in 1 opé.

(A <=> B) < 0
(A <=> B) > 0
(A <=> B) == 0

Ex:
const int x = 5, y = 3;

cout << ((x <=> y) < 0); // affiche 0 (false) car x > y
1st smaller than 2nd

cout << ((x <=> y) > 0); // affiche 1 (true) car x > y
1st bigger than 2nd
cout << ((x <=> y) == 0); // affiche 0 (false) car x != y
x == y

=> transpose the <>= instead of the spaceship

SURCHARGE D'OPÉRATEURS
-> fonctions qui défini son comportement
-> apprendre à un * à multi. des string par ex.
--------------
OPÉRATEURS LOGIQUES

not ! - or || - and &&

From L to R and stops asap
a && b -> éval. a 1st no éval. of b if a false
a || b -> éval. a 1st, no éval of b if a true
-> allows to write w/out risks to do a 0/div

Border effect -> of non éval of the right term
--------------
LOI DE MORGAN (the pute)

!(A && B) == (!A || !B)
!(A || B) == (!A && !B)
--------------
OPÉRATIONS SUR CHAR

char stock ASCII int of it
-> use the ASCII nb to do the opé.
--------------
STRING - CONCAT. -> +

= "Hello world" -> chaîne de char == char tab
= string("Hello world") -> objet

Can't do "Hello" + "world" -> + de 2 tab de char
if s put at the end -> promo of it into string
-> then we can concat.

No concat' with string + int
Nor  char + char

Can't acces to a specific char with a [6] for example in a string
Bcs string is a char tab
--------------
POINTEURS













































